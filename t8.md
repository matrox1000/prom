# Tema 8. Lenguaje SQL

- Consultas de selección avanzadas del lenguaje SQL.
- Optimización de sentencias.
- Entidades, atributos y relaciones.
- Índices.
- Disparadores.
- Restricciones de integridad.
- Operaciones sobre tablas con lenguaje SQL.

## Comandos SQL

- SELECT, FROM, WHERE: selecciona datos de una tabla.
```sql
SELECT name, id, age
FROM employees
WHERE age < 30
ORDER BY age DESC;  -- ASC para ordenar de forma ascendente.
```
- INSERT: inserta datos en una tabla.
```sql
INSERT INTO customers (customer_name, customer_email, customer_phone)
VALUES ('John Doe', 'john.doe@example.com', '123-456-7890');
```
- UPDATE: actualiza datos en una tabla.
```sql
UPDATE customers
SET customer_email = 'johndoe@example.com'
WHERE customer_name = 'John Doe';
```
- DELETE: elimina datos de una tabla.
```sql
DELETE FROM customers
WHERE customer_name = 'John Doe';
```

- GROUP BY / HAVING: agrupa datos y aplica condiciones a los grupos.
```sql
SELECT COUNT(*), country
FROM customers
GROUP BY country
HAVING COUNT(*) > 1;
```
- JOIN: combina datos de dos o más tablas.
```sql
SELECT customers.customer_name, orders.order_date
FROM customers
JOIN orders
ON customers.customer_id = orders.customer_id;
```
- UNION: combina resultados de dos o más consultas.
```sql
SELECT customer_name, customer_email
FROM customers
UNION
SELECT employee_name, employee_email
FROM employees;
```
- CREATE TABLE: crea una nueva tabla.
```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    employee_name VARCHAR(50),
    employee_age INT
);
```
- ALTER TABLE: modifica una tabla existente.
```sql
ALTER TABLE employees
ADD COLUMN employee_salary DECIMAL(10, 2);
```
- DROP TABLE: elimina una tabla.
```sql
DROP TABLE employees;
```
- CREATE INDEX: crea un índice en una tabla.
```sql
CREATE INDEX idx_name ON employees (employee_name);
```
- CREATE TRIGGER: crea un disparador en una tabla.
```sql
CREATE TRIGGER update_salary
AFTER UPDATE OF employee_salary ON employees
BEGIN
    UPDATE employees SET employee_salary = employee_salary * 1.1;
END;
```
- CONSTRAINTS: restricciones de integridad.
```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    employee_name VARCHAR(50) NOT NULL,
    employee_age INT CHECK (employee_age >= 18),
    employee_salary DECIMAL(10, 2) DEFAULT 0.0
);
```

## Advanced CRUD Operations

### Select-based inserts

En SQL, se pueden realizar inserciones basadas en consultas `SELECT` para copiar datos de una tabla a otra o para insertar datos calculados en una tabla.
```sql
INSERT  INTO dbo.Department
   (  DepartmentName ,
      CostCenter ,
      LocationId )
   ( SELECT    
      'Accounting' ,
      '6MRTG99RAR3N6BI443CRY0M3' ,
      0);
```
- Las columnas del select deben coincidir con las columnas del insert.
- El select no puede contener un `ORDER BY`.

```sql
CREATE TRIGGER trEmployeeInsert 
ON dbo.Employee FOR INSERT
AS
INSERT INTO dbo.EmployeeAudit
            ( EmployeeId ,
              FirstName ,
              LastName ,
              AuditAction ,
              AuditDateTime )
            SELECT   Inserted.EmployeeId ,
                     Inserted.FirstName ,
                     Inserted.LastName ,
                     'I', --Iisforinsert
                     GETDATE()
            FROM     Inserted;
```

TODO: por página 37


## Triggers
Un trigger en SQL es un procedimiento almacenado que se ejecuta automáticamente en respuesta a ciertos eventos en una tabla o vista.
Podremos hacer que un trigger se ejecute BEFORE o AFTER de un INSERT, UPDATE o DELETE.

### Sintaxis
```sql
CREATE TRIGGER trigger_name
[BEFORE | AFTER] [INSERT | UPDATE | DELETE]
ON table_name
FOR EACH ROW
BEGIN
    -- SQL statements
END;
```
 **`OLD`**, y **`NEW`** permiten acceder a los datos en la fila afectada por el trigger definido con `FOR EACH ROW`.


1. **OLD**: Contiene los valores anteriores de la fila antes de la acción (disponible en triggers `UPDATE` y `DELETE`). 

2. **NEW**: Representa los valores nuevos de la fila después de la acción (en triggers `INSERT` y `UPDATE`).

```sql
CREATE TRIGGER actualizar_precio
AFTER UPDATE ON productos
FOR EACH ROW
BEGIN
   IF NEW.precio <> OLD.precio THEN
       INSERT INTO historial_precio (producto_id, precio_anterior, precio_nuevo)
       VALUES (OLD.id, OLD.precio, NEW.precio);
   END IF;
END;
```
Aquí se almacena el precio anterior y el nuevo cuando cambia el precio de un producto.

ELiminar un trigger:
```sql
DROP TRIGGER IF EXISTS trigger_name;
```
No se permite la modificación de un trigger.

Podemos ver los trigger existentes con:
```sql
SHOW TRIGGERS;
```
### Tipos de triggers
Existen tres tipos principales de triggers (disparadores) en SQL, cada uno activado en diferentes eventos:

1. **Triggers DML (Data Manipulation Language)**: Se activan en operaciones como `INSERT`, `UPDATE`, o `DELETE`:
   - **AFTER**: Ejecuta el trigger después de la operación.
   - **BEFORE**: Ejecuta el trigger antes de la operación.
   - **INSTEAD OF**: Reemplaza la operación con el código del trigger.

   **Ejemplo**:
   ```sql
   CREATE TRIGGER after_insert
   AFTER INSERT ON empleados
   FOR EACH ROW
   BEGIN
       INSERT INTO log (accion, fecha) VALUES ('Nuevo empleado', NOW());
   END;
   ```

2. **Triggers DDL (Data Definition Language)**: Se disparan con sentencias `CREATE`, `ALTER` o `DROP`, útiles para auditar cambios en la estructura de la base de datos.

   **Ejemplo**:
   ```sql
   CREATE TRIGGER after_table_create
   AFTER CREATE ON DATABASE
   BEGIN
       INSERT INTO audit_log (accion, fecha) VALUES ('Nueva tabla creada', NOW());
   END;
   ```

3. **Triggers de inicio de sesión**: Responden a eventos de inicio de sesión (`LOGON`), permitiendo supervisar accesos o aplicar restricciones.

   **Ejemplo**:
   ```sql
   CREATE TRIGGER limit_login_time
   ON ALL SERVER FOR LOGON
   AS
   BEGIN
       IF DATEPART(hour, GETDATE()) NOT BETWEEN 9 AND 17
           ROLLBACK; -- Prohibe acceso fuera del horario laboral
   END;
   ```

Estos triggers permiten automatizar tareas y reforzar la seguridad y consistencia de la base de datos.


### Integrity Constraints

1. **NOT NULL**: Asegura que una columna no contenga valores nulos.
   ```sql
   CREATE TABLE empleados (
       id INT PRIMARY KEY,
       nombre VARCHAR(100) NOT NULL
   );
   ```

2. **UNIQUE**: Garantiza que todos los valores en una columna sean únicos.
   ```sql
   CREATE TABLE productos (
       id INT PRIMARY KEY,
       codigo VARCHAR(50) UNIQUE
   );
   ```

3. **PRIMARY KEY**: Identifica de manera única cada fila y no permite valores nulos.
   ```sql
   CREATE TABLE clientes (
       id INT PRIMARY KEY,
       nombre VARCHAR(100)
   );
   ```

4. **FOREIGN KEY**: Establece una relación entre dos tablas, asegurando que los valores coincidan con otra tabla.
   ```sql
   CREATE TABLE pedidos (
       id INT PRIMARY KEY,
       cliente_id INT,
       FOREIGN KEY (cliente_id) REFERENCES clientes(id)
   );
   ```

5. **CHECK**: Establece una condición que los valores en una columna deben cumplir.
   ```sql
   CREATE TABLE productos (
       id INT PRIMARY KEY,
       precio DECIMAL CHECK (precio >= 0)
   );
   ```
   Con `CHECK`, podemos usar expresiones como:
   - **`BETWEEN`**: Asegura que los valores estén dentro de un rango específico.
      ```sql
      CHECK (edad BETWEEN 18 AND 65)
      ```
   - **`IN`**: Verifica que el valor esté dentro de una lista de valores permitidos.
      ```sql
      CHECK (estado IN ('activo', 'inactivo', 'suspendido'))
      ```

6. **DEFAULT**: Asigna un valor predeterminado a una columna cuando no se especifica un valor al insertar.
   ```sql
   CREATE TABLE empleados (
       id INT PRIMARY KEY,
       nombre VARCHAR(100) NOT NULL,
       estado VARCHAR(10) DEFAULT 'activo'
   );
   ```

Podemos definir las constraints al crear la tabla o agregarlas despues con `ALTER TABLE`:
```sql
ALTER TABLE empleados
ADD CONSTRAINT nombre_not_null CHECK (nombre IS NOT NULL);
```



## Uso de JOINS en SQL

En SQL, los *joins* combinan filas de dos o más tablas en función de una condición relacionada. Aquí tienes los tipos principales con ejemplos:

1. **INNER JOIN**: Devuelve solo las filas con coincidencias en ambas tablas.
   ```sql
   SELECT a.nombre, b.pedido 
   FROM clientes a 
   INNER JOIN pedidos b ON a.id = b.cliente_id;
   ```

2. **LEFT JOIN**: Devuelve todas las filas de la tabla izquierda y las coincidentes de la derecha; si no hay coincidencia, muestra `NULL`.
   ```sql
   SELECT a.nombre, b.pedido 
   FROM clientes a 
   LEFT JOIN pedidos b ON a.id = b.cliente_id;
   ```

3. **RIGHT JOIN**: Similar al `LEFT JOIN`, pero devuelve todas las filas de la tabla derecha.
   ```sql
   SELECT a.nombre, b.pedido 
   FROM clientes a 
   RIGHT JOIN pedidos b ON a.id = b.cliente_id;
   ```

4. **FULL JOIN**: Devuelve todas las filas cuando hay coincidencia en cualquiera de las tablas; las no coincidentes son `NULL`.
   ```sql
   SELECT a.nombre, b.pedido 
   FROM clientes a 
   FULL OUTER JOIN pedidos b ON a.id = b.cliente_id;
   ```



## Optimización de consultas SQL



1. **Entender el plan de ejecución de consultas**: El plan de ejecución muestra cómo el motor de la base de datos ejecutará una consulta, ayudando a identificar cuellos de botella. Analizarlo permite hacer mejoras informadas en el rendimiento de la consulta.

   **Ejemplo**: Usar herramientas como `EXPLAIN` en MySQL para visualizar el plan de ejecución y ver el flujo de una consulta compleja.

2. **Uso de índices adecuados**: Crear índices en columnas utilizadas frecuentemente acelera la recuperación de datos y reduce el tiempo de ejecución de las consultas.

   **Ejemplo**: Crear un índice en una columna con `CREATE INDEX idx_nombre_columna ON tabla (columna);`.

3. **Evitar funciones en cláusulas WHERE**: Las funciones en WHERE impiden el uso de índices y afectan el rendimiento. Es mejor adaptar los valores de búsqueda para coincidir directamente con los datos almacenados.

   **Ejemplo**: En lugar de `SELECT * FROM tabla WHERE MONTH(fecha) = 5;`, es preferible `SELECT * FROM tabla WHERE fecha >= '2022-05-01' AND fecha < '2022-06-01';`.

4. **Reducir el uso de consultas anidadas**: Las subconsultas pueden ralentizar el sistema, así que es preferible usar JOINs para combinar tablas y obtener los resultados en una sola consulta.

   **Ejemplo**: En lugar de una subconsulta, usa un JOIN como `SELECT columna1, columna2 FROM tabla1 INNER JOIN tabla2 ON tabla1.id = tabla2.id;`.

5. **Limitar el número de filas devueltas**: Utilizar cláusulas como `LIMIT` o `TOP` ayuda a devolver solo las filas necesarias, reduciendo la carga en la base de datos.

   **Ejemplo**: Para limitar los resultados en MySQL, utiliza `SELECT * FROM tabla LIMIT 100;` para traer solo las primeras 100 filas.

6. **Actualizar las estadísticas de la base de datos**: Esto permite que el motor de la base de datos ejecute consultas con información actualizada, mejorando su rendimiento.

   **Ejemplo**: En SQL Server, se pueden actualizar las estadísticas con `UPDATE STATISTICS nombre_tabla`.

En SQL, `UNION` y `UNION ALL` son operadores que combinan los resultados de dos o más consultas `SELECT`. La principal diferencia entre ellos está en cómo manejan los registros duplicados:

## UNION vs. UNION ALL en SQL
1. **UNION**:
   - Elimina automáticamente los registros duplicados en el conjunto de resultados combinado.
   - Realiza una operación de ordenación interna para eliminar duplicados, lo que puede hacerla más lenta en consultas grandes.
   - **Ejemplo**:
     ```sql
     SELECT columna1 FROM tabla1
     UNION
     SELECT columna1 FROM tabla2;
     ```
     En este ejemplo, si ambas consultas devuelven los mismos valores en `columna1`, los duplicados se eliminarán en el resultado final.

2. **UNION ALL**:
   - Incluye todos los registros, incluidos los duplicados.
   - No requiere ordenación interna, lo que la hace más rápida en consultas grandes.
   - Es ideal si se necesita la lista completa sin eliminación de duplicados.
   - **Ejemplo**:
     ```sql
     SELECT columna1 FROM tabla1
     UNION ALL
     SELECT columna1 FROM tabla2;
     ```
     Aquí, todos los registros de ambas consultas se incluirán, incluso si hay duplicados.


TODO:
Chapter 3 More Advanced CRUD 
Chapter 5 Selecting From Yourself 
SQL INDEX (w3schools.com) 