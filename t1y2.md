# Temas 1 y 2. C# y POO
## Sintaxis y conceptos del lenguaje C#.

### C# Types and Operators

C# es un lenguaje fuertemente tipado. Tenemos que convertir explícitamente los tipos de datos.

```csharp
int total = int.Parse("359");
string message = 7.ToString();
```

Tambiñen podemos usar casting para convertir tipos de datos.

```csharp
double preciseLength = 5.61;
int roundedLength = (int)preciseLength;
```
La siguiente tabla muestra los tipos nativos en C#.

| Tipo de dato | Descripción |
| --- | --- |
| byte | Entero sin signo de 8 bits |
| sbyte | Entero con signo de 8 bits |
| short | Entero con signo de 16 bits |
| ushort | Entero sin signo de 16 bits |
| int | Entero con signo de 32 bits |
| uint | Entero sin signo de 32 bits |
| long (l) | Entero con signo de 64 bits |
| ulong (ul) | Entero sin signo de 64 bits |
| float (f) | Número de coma flotante de 32 bits |
| double (d) | Número de coma flotante de 64 bits |
| decimal (m) | Número decimal de 128 bits |
| bool | Valor booleano |
| char | Carácter Unicode de 16 bits |
| string | Secuencia de caracteres Unicode |

```csharp
// si hay ambigüedad en el tipo de dato se pueden usar los sufijos l, f, d, m, ul, ul
decimal price = 9.95m;
// podemos asignar un valor unicode a un char
char letter = '\u0058';
// y podemos obetner el valor unicode de un char
int value = (int)letter;
```
### Operadores
Tabla de operadores en c#.

| Operador | Descripción |
| --- | --- |
| Primarios | x.y x?.y f(x) a[x] x++ x-- new typeof default
checked unchecked nameof |
| Unarios | + - ! ~ ++x --x (T)x await x |
| Multiplicativos | * / % |
| Aditivos | + - |
| Desplazamiento | << >> |
| Relacionales y de tipo | < > <= >= is as |
| Igualdad | == != |
| AND lógico | & |
| XOR lógico | ^ |
| OR lógico | \| |
| AND lógico condicional | && |
| OR lógico condicional | \|\| |
| Coalescencia nula | ?? |
| Condicional | ?: |
| Asignación | = *= /= %= += -= <<= >>= &= ^= |= =>|


```csharp

int v1= 1;
// operadores ++ y -- 
int v2 = v1++; // v2 = 1, v1 = 2
int v3 = ++v1; // v3 = 3, v1 = 3
// Operador ternario.
int v4 = (v1 > 2) ? 1 : 0;
```

El Framework class library (FCL) de .NET ofrece más tipos de datos como el datetime:
```csharp
DateTime currentTime = DateTime.Now; // fecha y hora actual
string shortDateString = currentTime.ToShortDateString(); // solo fecha en string
string longDateString = currentTime.ToLongDateString(); // fecha y hora en string
string defaultDateString = currentTime.ToString(); // fecha y hora en string
DateTime tomorrow = currentTime.AddDays(1); // sumamos un día
```

Formateando cadenas de texto:
```csharp
string name = "Joe";
string helloViaConcatenation = "Hello, " + name + "!"; // concatenación
string helloViaStringFormat = string.Format("Hello, {0}!", name); // igual pero con string.Format

// Con string.Format podemos formatear la salida
// {0,-10} indica que el primer argumento se imprime en 10 caracteres a la izquierda
// {1:C} indica que el segundo argumento se imprime como moneda (currency)
string item = "bread";
decimal amount = 2.25m;
Console.WriteLine("{0,-10}{1:C}", item, amount);
Console.WriteLine($"{item} {amount}"); // interpolación (desde C# 6)

// nameof nos da el nombre de la variable
// con interpolación también podemos formatear la salida como con string.Format
Console.WriteLine($"{nameof(item)}: {item,-10} {nameof(amount)}: {amount:C}");

string input = Console.ReadLine(); // lee una línea de la consola
```


StringBuilder es más eficiente que concatenar strings, ya que string es inmutable y cada vez que concatenamos se crea un nuevo string en memoria

```csharp
using System.Text; // para usar StringBuilder
StringBuilder sb = new StringBuilder();
sb.Append("Your result is ");
sb.Append(result.ToString());
Console.WriteLine(sb.ToString());


```

### Control de flujo
```csharp
// if else
string action4 = null;
if (priceGain <= 2m)
{
    action4 = "Sell";
}
else if (priceGain > 2m && priceGain <= 3m)
{
    action4 = "Do Nothing";
}
else
{
    action4 = "Sell";
}

// switch
string currentWeather = "rain";
string equipment = null;
switch (currentWeather)
{
    case "sunny":
        equipment = "sunglasses";
        break;
    case "rain":
        equipment = "umbrella";
        break;
    case "cold":
    default:
        equipment = "jacket";
    break;
}

// todos los case deben tener un break, solo puedes no usar break si el case está vacío como en el case "cold" ( fall-through), en caso contrario el compalidor te derá un error
```

### Arrays y colecciones
```csharp
int[] oddNumbers = { 1, 3, 5 }; // array de 3 int con valores
int firstOdd = oddNumbers[0];

string[] names = new string[3]; // array de 3 strings null
names[1] = "Joe"; // asignamos un valor al segundo elemento
```
También podemos usar List, Stack, Queue y demás tipos del FCL
```csharp
List<int> numbers = new List<int> { 1, 2, 3 }; // lista de 3 int con valores
List<int> numbers2 = new List<int>(); // lista vacía
numbers.Add(4); // añadimos un valor al final
```

### Bucles

C# supports several loops, including for, foreach, while, and do

```csharp

double[] temperatures = { 72.3, 73.8, 75.1, 74.9 };
for (int i = 0; i < temperatures.Length; i++)
{
    Console.WriteLine(i);
}

foreach (int temperature in temperatures)
{
    Console.WriteLine(temperature);
}

int tempCount = 0;
while (tempCount < temperatures.Length)
{
    Console.WriteLine(tempCount);
    tempCount++;
}

int tempCount2 = 0;
do
{
    Console.WriteLine(tempCount2++);
}
while (tempCount2 <= temperatures.Length);
```

### Comentarios
```csharp
// comentario de una línea
/* comentario de varias
líneas */

 
/// <summary>
/// Esto es para documentar un método
/// </summary>

```



## Métodos y propiedades en C#.

Ejemplo de método en C#:

```csharp
static double AddNumbers(double firstNumber, double secondNumber)
{
return firstNumber + secondNumber;
}
```
Los métodos static no necesitan una instancia de la clase para ser llamados y no pueden usar variables de instancia.

Ejemplo de propiedad que implementa el get y el set en C#:

```csharp
public double Result { get; set; }
```

## Depuración de código con C#, gestión de errores y excepciones.

```csharp
static void HandleNullReference()
{
    Program prog = null;
    try
    {
        Console.WriteLine(prog.ToString());
    }
    catch (NullReferenceException ex)
    {
        Console.WriteLine(ex.Message);
    }
}
```

```csharp
static void HandleUncaughtException()
{
    Program prog = null;
    try
    {
        Console.WriteLine(prog.ToString()); // NullReferenceException
    }
    catch (ArgumentNullException ex)
    {
        Console.WriteLine("From ArgumentNullException: " + ex.Message);
    }
    catch (ArgumentException ex)
    {
        Console.WriteLine("From ArgumentException: " + ex.Message);
    }
    catch (Exception ex)
    { // este es el catch por defecto, como no hay un catch para NullReferenceException se ejecuta este
        Console.WriteLine("From Exception: " + ex.Message);
    }
    finally
    { // finally siempre se ejecuta cuando hay un try
        Console.WriteLine("Finally always executes.");
    }
}
```

```csharp
public class Address
{
    public string City { get; set; }
}
internal class Company
{
    public Address Address { get; set; }
}

    // Inside of a class...
    static void ThrowException()
    {
        try
        {   // lanzamos una excepción de tipo ArgumentNullException
            ValidateInput("something", new Company());
        }
        catch (ArgumentNullException ex) when (ex.ParamName == "inputString")
        { // La excepción no se maneja aquí porque el when no se cumple
            Console.WriteLine("From ArgumentNullException: " + ex.Message);
        }
        catch (ArgumentException ex)
        { // La excepción se maneja aquí, ya que ArgumentNullException es una subclase de ArgumentException
            Console.WriteLine("From ArgumentException: " + ex.Message);
        }
    }
    static void ValidateInput(string inputString, Company cmp)
    {
        // Podemos lanzar una excepción con parámetros
        if (inputString == null)
            throw new ArgumentNullException(nameof(inputString));
        if (cmp?.Address?.City == null)
            throw new ArgumentNullException(nameof(cmp));
    }
```


## Programación orientada a objetos con C#: clases.

C# es un lenguaje de programación orientado a objetos (POO). Soporta herencia, encapsulación, polimorfismo y abstracción.


### Herencia
```csharp
// ejemplo de herencia en C#
using System;
public class Calculator
{
    public double Add(double num1, double num2)
    {
        return num1 + num2;
    }
}

public class ScientificCalculator : Calculator
{
    public double Power(double num, double power)
    {
        return Math.Pow(num, power);
    }
}
public class ProgrammerCalculator : Calculator
{
    public int Or(int num1, int num2)
    {
        return num1 | num2;
    }
}
```

### Encapsulación

Las clases en C# pueden ser public o internal. Los miembros de una clase pueden ser public, private, protected, internal, protected internal o private protected.

Modificadores para clases:
- **public**: accesible desde cualquier otra clase.
- **internal**: accesible solo desde el ensamblado (proyecto o biblioteca) que lo contiene.

Modificadores para miembros de una clase:
- **public**: accesible desde cualquier clase.
- **internal**: accesible solo desde el ensamblado que lo contiene.
- **private** (por defecto): accesible solo desde la clase que lo contiene.
- **protected**: accesible desde las clases derivadas dentro y fuera del ensablando.
- **protected internal**: accesible desde cualquier clase del mismo ensamblado y además de las clases derivadas fuera del ensamblado.

- **private protected**: accesible solo desde las clases derivadas dentro del ensamblado.

Tabla resumen de acceso a miembros de una clase:

Modificador | Dentro del ensamblado || Fuera del ensamblado ||
--- | Todas | Solo derivadas | Todas | Solo derivadas |
--- | --- | --- | --- | --- |
public | Sí | Sí | Sí | Sí |
internal | Sí | Sí | No | No |
private | No | No | No | No |
protected | No | Sí | No | Sí |
protected internal | Sí | Sí | No | Sí |
private protected | No | Sí | No | No |






```csharp

### Class vs Struct

- Un struct no puede derivar de otra clase o struct.
- No se puede usar modificadores protected, protected internal o private protected en un struct.
- Un struct se pasa por valor, mientras que una clase se pasa por referencia.
- Un struct se aloja en el stack, mientras que una clase se aloja en el heap.


TODO: Atascado en pag 45




```csharp


## El lenguaje integrado de consultas (LINQ) en C#.


```csharp
// importamos Linq
using System.Linq 


// Ejemplo de uso de Linq, obetenemos una lista de clientes de la clase Company
IEnumerable<Customer> customers = 
    from cust in Company.Customers 
    select cust;

foreach (Customer cust in customers) Console.WriteLine(cust.Name);


// Podemos usar una clase nueva para crear la lista  IEnumerable<CustomerViewModel>

IEnumerable<CustomerViewModel> customerVMs = 
    from custVM in Company.Customers 
    select new CustomerViewModel { 
        Name = custVM.Name
    };

// Podemos hacer lo mismo con una clase anonima
var customers3 = 
    from cust3 in Company.Customers
    select new { 
        Name = cust3.Name 
    };

// luego usaremos var para recorrer la lista
foreach (var cust3 in customers3)
    Console.WriteLine(cust3.Name);


// evitar usar var en casos donde no se sepa que tipo de dato se esta usando
var response = DoSomethingAndReturnResults();

// podemos filtrar con where
var customers4 = 
    from cust4 in Company.Customers 
    where cust4.Name.Length > 3 && !cust4.Name.StartsWith("G") 
    select cust4;

// podemos ordenar con orderby
var customers5 = 
    from cust5 in Company.Customers 
    orderby cust5.Name descending 
    select cust5;

// podemos hacer uno o más join's con otras tablas
var customerOrders = 
    from cust in Company.Customers 
    join ord in Company.Orders 
        on cust.ID equals ord.CustomerID 
    select new { 
        ID = cust.ID, 
        Customer = cust.Name, 
        Item = ord.Description
    };

// En este caso es un inner join, si queremos un left join usamos tenemos que poner en el join DefaultIfEmpty

    join ord in Company.Orders.DefaultIfEmpty()

// podemos proyector un IEnumerable a un List, array, dictionary etc con ToList, ToArray, toDictionary, etc

var custList = 
    (from cust in Company.Customers
    select cust)
    .ToList();


```
LINQ utiliza ejecución diferida: la consulta no se ejecuta hasta que se hace un foreach o se llama proyecta el resultado con un ToList, por ejemplo.

```csharp
// Uniones (union), intersecciones(intersect) y diferencias(except)

var additionalCustomers =
    new List<Customer>
    {
        new Customer { ID = 1, Name = "Gary" }
    };
var customerUnion =
    Company.Customers
    .Union(additionalCustomers)
    .ToArray();

// First, FirstOrDefault, Single, SingleOrDefault, Last, and LastOrDefault

Console.WriteLine(Company.Customers.First().Name);

// First, Last o Single lanzan una InvalidOperationException si no hay elementos en la lista, para evitar esto usamos FirstOrDefault, LastOrDefault o SingleOrDefault

var empty =
    Company.Customers
    .Where(cust => cust.ID == 999)
    .SingleOrDefault();
if (empty == null)
    Console.WriteLine("No values returned.");