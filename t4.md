# Tema 4. PHP 8 – Sintaxis.

## Variables, tipos de datos, estructuras de control, arrays y funciones.

### Variables
Las variables en php tienen que empezar por una letra o un guión bajo:
```php
<?php
$var = 'Roberto';
$Var = 'Juan';
echo "$var, $Var";      // imprime "Roberto, Juan"

$4site = 'aun no';      // inválido; comienza con un número
$_4site = 'aun no';     // válido; comienza con un carácter de subrayado
$täyte = 'mansikka';    // válido; 'ä' es ASCII (Extendido) 228
?>
```

Uso de variables por referencia:
```php
<?php
$foo = 'Bob';                // Asigna el valor 'Bob' a $foo
$bar = &$foo;                // Referenciar $foo vía $bar.
$bar = "Mi nombre es $bar";  // Modifica $bar...
echo $bar;
echo $foo;                   // $foo también se modifica.
?>
```
No se puede usar `&` para referenciar con valores directamente ni con la devolución de una función.

```php
<?php
$foo = 25;
$bar = &$foo;      // Esta es una asignación válida.
$bar = &(24 * 7);  // Inválida; referencia una expresión sin nombre.

function test()
{
   return 25;
}

$bar = &test();    // Inválido.
?>
```

No es necesario inicializar las variables. Si hay contexto, se inicializan con el valor por defecto de cada tipo y si no, se inicializan con `NULL`.

### Variables predefinidas ¶


- **Superglobals:** Superglobals son variables internas que están disponibles siempre en todos los ámbitos
- **$GLOBALS:** Hace referencia a todas las variables disponibles en el ámbito global
- **$_SERVER:** Información del entorno del servidor y de ejecución
- **$_GET:** Variables HTTP GET
- **$_POST:** Variables POST de HTTP
- **$_FILES:** Variables de subida de ficheros HTTP
- **$_REQUEST:** Variables HTTP Request
- **$_SESSION:** Variables de sesión
- **$_ENV:** Variables de entorno
- **$_COOKIE:** Cookies HTTP
- **$php_errormsg:** El mensaje de error anterior
- **$http_response_header:** Encabezados de respuesta HTTP
- **$argc:** El número de argumentos pasados a un script
- **$argv:** Array de argumentos pasados a un script



TODO: Seguir con variables: predefinidas, ambitos, variables variables y variables de fuentes externas.


### Tipos de datos

Cada expresión en PHP tiene uno de los siguientes tipos incorporados dependiendo de su valor:

- null
- bool
- int
- float (número de punto flotante, también conocido como double)
- string
- array
- object: tipo de datos que representa una instancia de una clase (se usa con new para crear una instancia).
- callable: tipo de datos que representa un objeto que se puede llamar (se usa como función).
- resource: tipo de datos que representa un recurso externo, como un archivo, una conexión a una base de datos, etc.

### Estructuras de control

#### if
```php
<?php
if ($a > $b) {
    echo "a es mayor que b";
} elseif ($a == $b) {
    echo "a es igual que b";
} else {
    echo "a es menor que b";
}
?>
```
Sintaxis alternativa:
```php
<?php if ($a == 5): ?>
A es igual a 5
<?php elseif; ?>
```

Aquí tienes ejemplos y explicaciones de cada una de las estructuras de control que mencionas:

### `while`
```php
// La estructura 'while' repite el bloque de código mientras la condición sea verdadera.
$count = 0;
while ($count < 5) {
    echo $count; // Imprime el valor actual de $count
    $count++;    // Incrementa $count
}
```
Con sintaxis alternativa:
```php
<?php while ($count < 5): ?>
    <?= $count; ?>
    <?php $count++; ?>
<?php endwhile; ?>
```

### `do-while`
```php
// La estructura 'do-while' garantiza que el bloque de código se ejecute al menos una vez, independientemente de la condición.
$count = 0;
do {
    echo $count;  // Imprime el valor actual de $count
    $count++;     // Incrementa $count
} while ($count < 5); // Condición para repetir el ciclo
```
No admite sintaxis alternativa.

### `for`
```php
// El ciclo 'for' tiene tres partes: inicialización, condición y actualización.
for ($i = 0; $i < 5; $i++) {
    echo $i; // Imprime el valor de $i en cada iteración
}
```
Con sintaxis alternativa:
```php
<?php for ($i = 0; $i < 5; $i++): ?>
    <?= $i; ?>
<?php endfor; ?>
```

### `foreach`
```php
// 'foreach' recorre cada elemento de un array o colección.
$array = [1, 2, 3, 4, 5];
foreach ($array as $value) {
    echo $value;  // Imprime cada valor del array
}
```
Con sintaxis alternativa:
```php
<?php foreach ($array as $value): ?>
    <?= $value; ?>
<?php endforeach; ?>
```

### `break`
```php
// 'break' se usa para salir de un ciclo antes de que termine.
for ($i = 0; $i < 10; $i++) {
    if ($i == 5) {
        break;  // Sale del ciclo cuando $i es 5
    }
    echo $i;
}
```
Con sintaxis alternativa:
```php
<?php for ($i = 0; $i < 10; $i++): ?>
    <?php if ($i == 5) break; ?>
    <?= $i; ?>
<?php endfor; ?>
```

### `continue`
```php
// 'continue' salta el resto de la iteración actual y pasa a la siguiente.
for ($i = 0; $i < 10; $i++) {
    if ($i == 5) {
        continue;  // Salta cuando $i es 5
    }
    echo $i;
}
```

### `switch`
```php
// 'switch' selecciona una parte del código a ejecutar en función del valor.
$day = 'Monday';
switch ($day) {
    case 'Monday':
        echo "Start of the week!";
        break;
    case 'Friday':
        echo "End of the week!";
        break;
    default:
        echo "Regular day";
}
```
Con sintaxis alternativa:
```php
<?php switch ($day): ?>
    <?php case 'Monday': ?>
        Start of the week!
        <?php break; ?>
    <?php case 'Friday': ?>
        End of the week!
        <?php break; ?>
    <?php default: ?>
        Regular day
<?php endswitch; ?>
```

### `match` (PHP 8.0+)
a expresión match es similar a una sentencia switch pero tiene algunas diferencias clave:

Un brazo de match compara los valores estrictamente (===) en lugar de hacerlo de forma suelta como lo hace la sentencia switch.
Una expresión match retorna un valor.
Los brazos de Match no pasan a casos posteriores como lo hacen las sentencias switch.
Una expresión match debe ser completa.
```php
// 'match' es similar a 'switch', pero es más expresivo y flexible.
$day = 'Monday';
echo match ($day) {
    'Monday' => "Start of the week!",
    'Friday' => "End of the week!",
    default => "Regular day",
};
```

### `declare`
```php
// 'declare' establece directivas para el compilador de PHP, como por ejemplo activar el modo estricto o definir la codificación de caracteres.
declare(strict_types=1);  // Activa la verificación de tipos estricta
function sum(int $a, int $b): int {
    return $a + $b;  // Si se pasan valores no enteros, causará un error
}
```

###. `return`
```php
// 'return' se utiliza para devolver un valor desde una función.
function add($a, $b) {
    return $a + $b;  // Devuelve la suma de $a y $b
}
echo add(5, 3);  // Muestra 8
```

###. `require`
```php
// 'require' incluye un archivo externo y genera un error fatal si el archivo no existe.
require 'config.php';  // El código no continuará si el archivo no se encuentra
```

###. `include`
```php
// 'include' también incluye un archivo, pero genera solo una advertencia si el archivo no se encuentra.
include 'header.php';  // Continúa ejecutando el código incluso si el archivo no existe
```

###. `require_once`
```php
// 'require_once' incluye el archivo solo una vez, evitando duplicados si ya fue incluido.
require_once 'config.php';  // El archivo será requerido una sola vez
```

###. `include_once`
```php
// 'include_once' incluye el archivo solo si no ha sido incluido antes.
include_once 'header.php';  // Se asegura de que no se incluya más de una vez
```

###. `goto`
```php
// 'goto' salta a una etiqueta específica en el código.
$i = 0;
start:
$i++;
echo $i;
if ($i < 3) {
    goto start;  // Salta a la etiqueta 'start' si $i es menor que 3
}
```

Cada uno de estos elementos tiene un rol en la estructura de control y manejo de archivos de PHP, permitiendo modular el flujo de la ejecución y la inclusión de dependencias de manera eficiente.

### Arrays

Un array en PHP es en realidad un mapa ordenado. Un mapa es un tipo de datos que asocia valores con claves. Este tipo se optimiza para varios usos diferentes; se puede emplear como un array, lista (vector), tabla asociativa (tabla hash - una implementación de un mapa), diccionario, colección, pila, cola, y posiblemente más. Ya que los valores de un array pueden ser otros arrays, también son posibles árboles y arrays multidimensionales.

```php
<?php
$array = array(
    "foo" => "bar",
    "bar" => "foo",
);

// a partir de PHP 5.4
$array = [
    "foo" => "bar",
    "bar" => "foo",
];
?>
```
La clave puede ser un integer o un string. El valor puede ser de cualquier tipo. Si la clave es:
- Un string con un número entero válido, se convertirá a un integer.
- Un float también se convertirá a un integer eliminando la parte fracconaria.
- Un booleano se convertirá a un integer con valor 0 o 1.
- Un null se convertirar a cadena vacía.

Los arrays pueden contener claves integer y string al mismo tiempo.
Podemos no poner la clave y se utilizará integer autoincrementado del último elemento:
```php
<?php
$array = array(
    "foo", //0
    "bar", //1
    "hello", //2
    "world" //3
);
?>
```
Podemos definir solo claves para algunos elementos:
```php
<?php
$array = array(
         "a", // 0
         "b", // 1
    6 => "c", // 6
         "d", // 7
);
?>
```
#### Acceso a los elementos
```php
$array = array(
    "foo" => "bar",
    42    => 24,
    "multi" => array(
         "dimensional" => array(
             "array" => "foo"
         )
    )
);

var_dump($array["foo"]); // "bar"
var_dump($array[42]);   // 24
var_dump($array["multi"]["dimensional"]["array"]); // "foo"
?>
```
#### Modificar elementos
```php
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // Esto es lo mismo que $arr[13] = 56;
                // en este punto de el script

$arr["x"] = 42; // Esto agrega un nuevo elemento a
                // el array con la clave "x"

unset($arr[5]); // Esto elimina el elemento del array

unset($arr);    // Esto elimina el array completo
?>
```

#### Array unpacking
```php
<?php
// Using short array syntax.
// Also, works with array() syntax.
$arr1 = [1, 2, 3];
$arr2 = [...$arr1]; //[1, 2, 3]
$arr3 = [0, ...$arr1]; //[0, 1, 2, 3]
$arr4 = [...$arr1, ...$arr2, 111]; //[1, 2, 3, 1, 2, 3, 111]
$arr5 = [...$arr1, ...$arr1]; //[1, 2, 3, 1, 2, 3]
?>
```
Unpacking an array with the ... operator follows the semantics of the array_merge() function. That is, later string keys overwrite earlier ones and integer keys are renumbered:

```php
<?php
// string key
$arr1 = ["a" => 1];
$arr2 = ["a" => 2];
$arr3 = ["a" => 0, ...$arr1, ...$arr2];
var_dump($arr3); // ["a" => 2]

// integer key
$arr4 = [1, 2, 3];
$arr5 = [4, 5, 6];
$arr6 = [...$arr4, ...$arr5];
var_dump($arr6); // [1, 2, 3, 4, 5, 6]
// Which is [0 => 1, 1 => 2, 2 => 3, 3 => 4, 4 => 5, 5 => 6]
// where the original integer keys have not been retained.
?>
```
#### Operadores para arrays
| Ejemplo   | Nombre     | Resultado                                                                                     |
|-----------|------------|-----------------------------------------------------------------------------------------------|
| `$a + $b` | Unión      | Unión de `$a` y `$b`.                                                                          |
| `$a == $b`| Igualdad   | `true` si `$a` y `$b` tienen las mismas parejas clave/valor.                                    |
| `$a === $b`| Identidad | `true` si `$a` y `$b` tienen las mismas parejas clave/valor en el mismo orden y de los mismos tipos. |
| `$a != $b`| Desigualdad| `true` si `$a` no es igual a `$b`.                                                             |
| `$a <> $b`| Desigualdad| `true` si `$a` no es igual a `$b`.                                                             |
| `$a !== $b`| No-identidad | `true` si `$a` no es idéntica a `$b`.                                                       |

### Funciones
```php
<?php
function hacer_café($tipo = "capuchino")
{
    return "Hacer una taza de $tipo.\n";
}
echo hacer_café(); // Hacer una taza de capuchino.
echo hacer_café(null); // Hacer una taza de .
echo hacer_café("espresso"); // Hacer una taza de espresso.
?>
```
Podemos definir los tipos de los parámetros:
```php
<?php
function sumar(int $a, int $b) {
    return $a + $b;
}
?>
```
Argumentos variables: con el token ... Serán pasados a la variable dada como un array.
```php
<?php
function sum(...$números) {
    $acc = 0;
    foreach ($números as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
```
Por defecto los tipos de los argumentos se convierten:
```php
<?php
function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2)); // 3
var_dump(sum(1.5, 2.5)); // 3
?>
```
Pero podemos hacerlo fuertemente tipado con declare:

```php
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2)); // 3
var_dump(sum(1.5, 2.5)); // Fatal error
?>
```

Funciones anónimas:
```php
<?php
$saludo = function($nombre)
{
    printf("Hola %s\r\n", $nombre);
};

$saludo('Mundo');
$saludo('PHP');
?>
```
Herencia de variables de un ámbito padre con use
```php
<?php
$mensaje = 'hola';

// Sin "use"
$ejemplo = function () {
    var_dump($mensaje);
};
$ejemplo(); // NULL

// Heredar $mensaje
$ejemplo = function () use ($mensaje) {
    var_dump($mensaje);
};
$ejemplo(); // "hola"

// El valor de la variable heredada está cuando la función
// está definida, no cuando se le invoca
$mensaje = 'mundo';
$ejemplo(); // "hola"
?>
```

Podemos definir funciones de flecha:

```php
$fn1 = fn($x) => $x + $y;
// equivalent to using $y by value:
$fn2 = function ($x) use ($y) {
    return $x + $y;
};
```

Funciones de arrays:

Creación y manipulación de arrays
1. **`array()`** — Crea un array. Esta es la función fundamental para definir arrays en PHP.
2. **`array_merge()`** — Combina dos o más arrays en uno.
3. **`array_push()`** — Inserta uno o más elementos al final de un array.
4. **`array_pop()`** — Extrae el último elemento del array.
5. **`array_shift()`** — Quita el primer elemento del array.
6. **`array_unshift()`** — Añade uno o más elementos al inicio de un array.
7. **`array_slice()`** — Extrae una porción de un array, sin alterar el array original.
8. **`array_splice()`** — Elimina o reemplaza una porción de un array.

Búsqueda y filtrado
9. **`array_search()`** — Busca un valor en un array y devuelve la clave correspondiente.
10. **`in_array()`** — Comprueba si un valor existe en un array.
11. **`array_filter()`** — Filtra los elementos de un array usando una función de devolución de llamada.

Ordenación y transformación
12. **`sort()`** — Ordena un array en orden ascendente.
13. **`rsort()`** — Ordena un array en orden descendente.
14. **`array_reverse()`** — Devuelve el array en orden inverso.
15. **`array_map()`** — Aplica una función a cada elemento de uno o más arrays.

Obtención de claves y valores
1.  **`array_keys()`** — Devuelve todas las claves de un array.
2.  **`array_values()`** — Devuelve todos los valores de un array.
3.  **`array_key_exists()`** — Comprueba si una clave dada existe en un array.

Comparación de arrays
1.  **`array_diff()`** — Calcula la diferencia entre arrays.
2.  **`array_intersect()`** — Calcula la intersección de arrays (valores comunes).

Otros usos comunes
1.  **`array_unique()`** — Elimina valores duplicados de un array.
2.  **`array_count_values()`** — Cuenta el número de veces que aparece cada valor en un array.
3.  **`array_reduce()`** — Reduce un array a un solo valor usando una función de devolución de llamada.
4.  **`array_rand()`** — Selecciona una o más claves aleatorias de un array.


## Programación orientada a objeto.

Una clase puede tener sus propias constantes, variables (llamadas "propiedades"), y funciones (llamados "métodos").

Ejemplo Definición de una clase sencilla
```php
<?php
class ClaseSencilla
{
    // Declaración de una propiedad
    public $var = 'un valor predeterminado';

    // Declaración de un método
    public function mostrarVar() {
        echo $this->var;
    }
}
?>
```





## Control de sesiones.

## Control de errores.

## Conexiones a BD.
OCI8 permite acceder a Oracle Database 12c, 11g, 10g, 9i y 8i. Admiten sentencias SQL y PL/SQL. Sus características básicas incluyen el control de transacciones, la vinculación de variables de PHP a parámetros de sustitución de Oracle, y la admisión de tipos de objetos grandes (LOB) y colecciones.

### Conexión y consulta básica

```php
<?php

// conectamos a la bd con el usuario hr y la contraseña welcome, y connection_string 'localhost/XE'
$conexión = oci_connect('hr', 'welcome', 'localhost/XE');

if (!$conexión) {
    $e = oci_error();
    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);
}

// Preparar la sentencia
$stid = oci_parse($conexión, 'SELECT * FROM departments');
if (!$stid) {
    $e = oci_error($conexión);
    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);
}

// Realizar la lógica de la consulta
$r = oci_execute($stid);
if (!$r) {
    $e = oci_error($stid);
    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);
}

// Obtener los resultados de la consulta
print "<table border='1'>\n";
while ($fila = oci_fetch_array($stid, OCI_ASSOC+OCI_RETURN_NULLS)) {
    print "<tr>\n";
    foreach ($fila as $elemento) {
        print "    <td>" . ($elemento !== null ? htmlentities($elemento, ENT_QUOTES) : "") . "</td>\n";
    }
    print "</tr>\n";
}
print "</table>\n";

oci_free_statement($stid);
oci_close($conexión);
?>
```
### Inserción con variables vinculadas

```php
?php

// Antes de ejecutarlo, cree la tabla:
//   CREATE TABLE MYTABLE (mid NUMBER, myd VARCHAR2(20));

$conexión = oci_connect('hr', 'welcome', 'localhost/XE');
if (!$conexión) {
    $e = oci_error();
    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);
}

$stid = oci_parse($conexión, 'INSERT INTO MYTABLE (mid, myd) VALUES(:myid, :mydata)');

$id = 60;
$datos = 'Algunos datos';

oci_bind_by_name($stid, ':myid', $id);
oci_bind_by_name($stid, ':mydata', $datos);

$r = oci_execute($stid);  // ejecuta y consigna

if ($r) {
    print "Una fila insertada";
}

oci_free_statement($stid);
oci_close($conexión);

?>
```
### Uso de funciones y procedimientos almacenados de PL/SQL

```php
<?php

/*
  Antes de ejecutar el programa de PHP, cree un procedimiento almacenado en
  SQL*Plus or SQL Developer:

  CREATE OR REPLACE PROCEDURE myproc(p1 IN NUMBER, p2 OUT NUMBER) AS
  BEGIN
      p2 := p1 * 2;
  END;

*/

$conexión = oci_connect('hr', 'welcome', 'localhost/XE');
if (!$conexión) {
    $e = oci_error();
    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);
}

$p1 = 8;

$stid = oci_parse($conexión, 'begin myproc(:p1, :p2); end;');
oci_bind_by_name($stid, ':p1', $p1);
oci_bind_by_name($stid, ':p2', $p2, 40);

oci_execute($stid);

print "$p2\n";   // imprime 16

oci_free_statement($stid);
oci_close($conexión);

?>
```

Con cursor:

```php
<?php
/*
  Cree una función almacenada de PL/SQL como:

  CREATE OR REPLACE FUNCTION myfunc(p1 IN NUMBER) RETURN SYS_REFCURSOR AS
      rc SYS_REFCURSOR;
  BEGIN
      OPEN rc FOR SELECT city FROM locations WHERE ROWNUM < p1;
      RETURN rc;
  END;
*/

$conexión = oci_connect('hr', 'welcome', 'localhost/XE');

$stid = oci_parse($conexión, 'SELECT myfunc(5) AS mfrc FROM dual');
oci_execute($stid);

echo "<table border='1'>\n";
while (($fila = oci_fetch_array($stid, OCI_ASSOC))) {
    echo "<tr>\n";
    $rc = $fila['MFRC'];
    oci_execute($rc);  // el valor de la columna devuelta por la consulta es un ref cursor
    while (($fila_rc = oci_fetch_array($rc, OCI_ASSOC))) {   
        echo "    <td>" . $fila_rc['CITY'] . "</td>\n";
    }
    oci_free_statement($rc);
    echo "</tr>\n";
}
echo "</table>\n";

// La salida es:
//   Beijing
//   Bern
//   Bombay
//   Geneva

oci_free_statement($stid);
oci_close($conexión);

?>
```

