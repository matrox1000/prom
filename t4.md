# Tema 4. PHP 8 – Sintaxis.

## Variables, tipos de datos, estructuras de control, arrays y funciones.

### Variables
Las variables en php tienen que empezar por una letra o un guión bajo:
```php
<?php
$var = 'Roberto';
$Var = 'Juan';
echo "$var, $Var";      // imprime "Roberto, Juan"

$4site = 'aun no';      // inválido; comienza con un número
$_4site = 'aun no';     // válido; comienza con un carácter de subrayado
$täyte = 'mansikka';    // válido; 'ä' es ASCII (Extendido) 228
?>
```



No es necesario inicializar las variables. Si hay contexto, se inicializan con el valor por defecto de cada tipo y si no, se inicializan con `NULL`.

### Tipos de datos

Cada expresión en PHP tiene uno de los siguientes tipos incorporados dependiendo de su valor:

- null
- bool
- int
- float (número de punto flotante, también conocido como double)
- string
- array
- object: tipo de datos que representa una instancia de una clase (se usa con new para crear una instancia).
- callable: tipo de datos que representa un objeto que se puede llamar (se usa como función).
- resource: tipo de datos que representa un recurso externo, como un archivo, una conexión a una base de datos, etc.

### Estructuras de control

#### if
```php
<?php
if ($a > $b) {
    echo "a es mayor que b";
} elseif ($a == $b) {
    echo "a es igual que b";
} else {
    echo "a es menor que b";
}
?>
```
Sintaxis alternativa:
```php
<?php if ($a == 5): ?>
A es igual a 5
<?php elseif; ?>
```

Aquí tienes ejemplos y explicaciones de cada una de las estructuras de control que mencionas:

### `while`
```php
// La estructura 'while' repite el bloque de código mientras la condición sea verdadera.
$count = 0;
while ($count < 5) {
    echo $count; // Imprime el valor actual de $count
    $count++;    // Incrementa $count
}
```
Con sintaxis alternativa:
```php
<?php while ($count < 5): ?>
    <?= $count; ?>
    <?php $count++; ?>
<?php endwhile; ?>
```

### `do-while`
```php
// La estructura 'do-while' garantiza que el bloque de código se ejecute al menos una vez, independientemente de la condición.
$count = 0;
do {
    echo $count;  // Imprime el valor actual de $count
    $count++;     // Incrementa $count
} while ($count < 5); // Condición para repetir el ciclo
```
No admite sintaxis alternativa.

### `for`
```php
// El ciclo 'for' tiene tres partes: inicialización, condición y actualización.
for ($i = 0; $i < 5; $i++) {
    echo $i; // Imprime el valor de $i en cada iteración
}
```
Con sintaxis alternativa:
```php
<?php for ($i = 0; $i < 5; $i++): ?>
    <?= $i; ?>
<?php endfor; ?>
```

### `foreach`
```php
// 'foreach' recorre cada elemento de un array o colección.
$array = [1, 2, 3, 4, 5];
foreach ($array as $value) {
    echo $value;  // Imprime cada valor del array
}
```
Con sintaxis alternativa:
```php
<?php foreach ($array as $value): ?>
    <?= $value; ?>
<?php endforeach; ?>
```

### `break`
```php
// 'break' se usa para salir de un ciclo antes de que termine.
for ($i = 0; $i < 10; $i++) {
    if ($i == 5) {
        break;  // Sale del ciclo cuando $i es 5
    }
    echo $i;
}
```
Con sintaxis alternativa:
```php
<?php for ($i = 0; $i < 10; $i++): ?>
    <?php if ($i == 5) break; ?>
    <?= $i; ?>
<?php endfor; ?>
```

### `continue`
```php
// 'continue' salta el resto de la iteración actual y pasa a la siguiente.
for ($i = 0; $i < 10; $i++) {
    if ($i == 5) {
        continue;  // Salta cuando $i es 5
    }
    echo $i;
}
```

### `switch`
```php
// 'switch' selecciona una parte del código a ejecutar en función del valor.
$day = 'Monday';
switch ($day) {
    case 'Monday':
        echo "Start of the week!";
        break;
    case 'Friday':
        echo "End of the week!";
        break;
    default:
        echo "Regular day";
}
```
Con sintaxis alternativa:
```php
<?php switch ($day): ?>
    <?php case 'Monday': ?>
        Start of the week!
        <?php break; ?>
    <?php case 'Friday': ?>
        End of the week!
        <?php break; ?>
    <?php default: ?>
        Regular day
<?php endswitch; ?>
```

### `match` (PHP 8.0+)
a expresión match es similar a una sentencia switch pero tiene algunas diferencias clave:

Un brazo de match compara los valores estrictamente (===) en lugar de hacerlo de forma suelta como lo hace la sentencia switch.
Una expresión match retorna un valor.
Los brazos de Match no pasan a casos posteriores como lo hacen las sentencias switch.
Una expresión match debe ser completa.
```php
// 'match' es similar a 'switch', pero es más expresivo y flexible.
$day = 'Monday';
echo match ($day) {
    'Monday' => "Start of the week!",
    'Friday' => "End of the week!",
    default => "Regular day",
};
```

###. `require`
```php
// 'require' incluye un archivo externo y genera un error fatal si el archivo no existe.
require 'config.php';  // El código no continuará si el archivo no se encuentra
```

###. `include`
```php
// 'include' también incluye un archivo, pero genera solo una advertencia si el archivo no se encuentra.
include 'header.php';  // Continúa ejecutando el código incluso si el archivo no existe
```

###. `require_once`
```php
// 'require_once' incluye el archivo solo una vez, evitando duplicados si ya fue incluido.
require_once 'config.php';  // El archivo será requerido una sola vez
```

###. `include_once`
```php
// 'include_once' incluye el archivo solo si no ha sido incluido antes.
include_once 'header.php';  // Se asegura de que no se incluya más de una vez
```

###. `goto`
```php
// 'goto' salta a una etiqueta específica en el código.
$i = 0;
start:
$i++;
echo $i;
if ($i < 3) {
    goto start;  // Salta a la etiqueta 'start' si $i es menor que 3
}
```


### Arrays

Un array en PHP es en realidad un mapa ordenado. Un mapa es un tipo de datos que asocia valores con claves. Este tipo se optimiza para varios usos diferentes; se puede emplear como un array, lista (vector), tabla asociativa (tabla hash - una implementación de un mapa), diccionario, colección, pila, cola, y posiblemente más. Ya que los valores de un array pueden ser otros arrays, también son posibles árboles y arrays multidimensionales.

```php
<?php
$array = array(
    "foo" => "bar",
    "bar" => "foo",
);

// a partir de PHP 5.4
$array = [
    "foo" => "bar",
    "bar" => "foo",
];
?>
```
La clave puede ser un integer o un string. El valor puede ser de cualquier tipo. Si la clave es:
- Un string con un número entero válido, se convertirá a un integer.
- Un float también se convertirá a un integer eliminando la parte fracconaria.
- Un booleano se convertirá a un integer con valor 0 o 1.
- Un null se convertirar a cadena vacía.

Los arrays pueden contener claves integer y string al mismo tiempo.
Podemos no poner la clave y se utilizará integer autoincrementado del último elemento:
```php
<?php
$array = array(
    "foo", //0
    "bar", //1
    "hello", //2
    "world" //3
);
?>
```
Podemos definir solo claves para algunos elementos:
```php
<?php
$array = array(
         "a", // 0
         "b", // 1
    6 => "c", // 6
         "d", // 7
);
?>
```
#### Acceso a los elementos
```php
$array = array(
    "foo" => "bar",
    42    => 24,
    "multi" => array(
         "dimensional" => array(
             "array" => "foo"
         )
    )
);

var_dump($array["foo"]); // "bar"
var_dump($array[42]);   // 24
var_dump($array["multi"]["dimensional"]["array"]); // "foo"
?>
```
#### Modificar elementos
```php
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // Esto es lo mismo que $arr[13] = 56;
                // en este punto de el script

$arr["x"] = 42; // Esto agrega un nuevo elemento a
                // el array con la clave "x"

unset($arr[5]); // Esto elimina el elemento del array

unset($arr);    // Esto elimina el array completo
?>
```

## Programación orientada a objeto.

PHP 8 ofrece un conjunto completo de características para la POO. 

### 1. **Clases y Objetos**

```php
<?php
class Persona {
    public $nombre;
    public $edad;

    public function saludar() {
        return "Hola, mi nombre es " . $this->nombre;
    }
}

// Crear un objeto (instancia) de la clase
$persona1 = new Persona();
$persona1->nombre = "Carlos";
$persona1->edad = 30;

echo $persona1->saludar();  // Output: Hola, mi nombre es Carlos
?>
```
- **`class Persona`** define una clase.
- **`$nombre`** y **`$edad`** son **propiedades**.
- **`saludar()`** es un **método**.
- **`$this`** es usado dentro de la clase para referirse al objeto actual.

### 2. **Visibilidad (Modificadores de Acceso)**
PHP ofrece tres modificadores de acceso: **public**, **protected** y **private**.

- **public**: accesible desde cualquier parte.
- **protected**: accesible solo dentro de la clase y sus subclases.
- **private**: accesible solo dentro de la clase donde se define.

```php
<?php
class Persona {
    private $nombre;

    public function setNombre($nombre) {
        $this->nombre = $nombre;
    }

    public function getNombre() {
        return $this->nombre;
    }
}

$persona1 = new Persona();
$persona1->setNombre("Carlos");
echo $persona1->getNombre();  // Output: Carlos
?>
```
En este ejemplo, la propiedad **`$nombre`** es privada, por lo que solo se puede acceder a ella mediante los métodos **`setNombre()`** y **`getNombre()`**.

### 3. **Constructores y Destructores**
Los podemos definir con los métodos **`__construct()`** y **`__destruct()`**.

#### Ejemplo:
```php
<?php
class Persona {
    public $nombre;

    // Constructor
    public function __construct($nombre) {
        $this->nombre = $nombre;
    }

    public function saludar() {
        return "Hola, mi nombre es " . $this->nombre;
    }
    public function __destruct() {
    // Código de limpieza o tareas que realizar al destruir el objeto
    }
}

$persona1 = new Persona("Carlos");
echo $persona1->saludar();  // Output: Hola, mi nombre es Carlos
?>
```
El constructor **`__construct()`** puede recibir parámetros al instanciar la clase, permitiendo inicializar propiedades.

### 4. **Herencia**

```php
<?php
class Persona {
    public $nombre;

    public function __construct($nombre) {
        $this->nombre = $nombre;
    }

    public function saludar() {
        return "Hola, mi nombre es " . $this->nombre;
    }
}

// La clase Empleado hereda de Persona
class Empleado extends Persona {
    public $puesto;

    public function __construct($nombre, $puesto) {
        parent::__construct($nombre);  // Llamar al constructor de la clase padre
        $this->puesto = $puesto;
    }

    public function mostrarPuesto() {
        return $this->nombre . " trabaja como " . $this->puesto;
    }
}

$empleado1 = new Empleado("Ana", "Desarrolladora");
echo $empleado1->mostrarPuesto();  // Output: Ana trabaja como Desarrolladora
?>
```
- **`extends`** permite que una clase (Empleado) herede de otra (Persona).
- **`parent::__construct()`** llama al constructor de la clase padre.

### 5. **Métodos Estáticos**
Un método estático pertenece a la clase, no a una instancia de ella, y puede ser llamado sin crear un objeto.

#### Ejemplo:
```php
<?php
class Utilidades {
    public static function saludar() {
        return "Hola desde un método estático";
    }
}

// Llamar al método estático sin crear una instancia
echo Utilidades::saludar();  // Output: Hola desde un método estático
?>
```

Llamar a un método no estático sin instanciar la clase generará un error.

### 6. **Interfaces**
Una **interfaz** define métodos que las clases deben implementar, pero no proporciona la implementación de esos métodos.

```php
<?php
interface Animal {
    public function hacerSonido();
}

class Perro implements Animal {
    public function hacerSonido() {
        return "Guau!";
    }
}

$miPerro = new Perro();
echo $miPerro->hacerSonido();  // Output: Guau!
?>
```
- **`interface`** define los métodos.
- La clase **`Perro`** implementa la interfaz y debe definir el método **`hacerSonido()`**.

### 7. **Polimorfismo**
El polimorfismo permite usar una clase hija como si fuera de la clase padre, siempre que ambas compartan los mismos métodos.

#### Ejemplo:
```php
<?php
class Vehiculo {
    public function arrancar() {
        return "El vehículo está arrancando";
    }
}

class Coche extends Vehiculo {
    public function arrancar() {
        return "El coche está arrancando";
    }
}

class Moto extends Vehiculo {
    public function arrancar() {
        return "La moto está arrancando";
    }
}

function arrancarVehiculo(Vehiculo $vehiculo) {
    return $vehiculo->arrancar();
}

$coche = new Coche();
$moto = new Moto();

echo arrancarVehiculo($coche);  // Output: El coche está arrancando
echo arrancarVehiculo($moto);   // Output: La moto está arrancando
?>
```

### 8. **Traits**
Un **trait** es un mecanismo que permite reutilizar código en múltiples clases.

#### Ejemplo:
```php
<?php
trait Saludador {
    public function saludar() {
        return "Hola!";
    }
}

class Persona {
    use Saludador;
}

class Robot {
    use Saludador;
}

$persona = new Persona();
echo $persona->saludar();  // Output: Hola!

$robot = new Robot();
echo $robot->saludar();  // Output: Hola!
?>
```
- Los **traits** permiten compartir métodos entre varias clases.





## Control de sesiones.

El manejo de **sesiones** en PHP es una herramienta clave para mantener la **persistencia de datos** entre las solicitudes (requests) de los usuarios. Las sesiones permiten almacenar información sobre un usuario a lo largo de sus interacciones con una aplicación web, sin necesidad de volver a autenticar o transmitir datos en cada solicitud.

### ¿Cómo funcionan las sesiones?
- **Sesión**: Una sesión en PHP guarda información sobre un usuario (como el ID de usuario, el carrito de compras, etc.) en el servidor, asociada con un identificador único (ID de sesión) que se almacena en una **cookie** en el navegador del cliente.
- **Superglobal $_SESSION**: PHP proporciona la superglobal `$_SESSION` para almacenar y acceder a los datos de sesión en el servidor.
  

### 1. **Iniciar una sesión**
Antes de utilizar cualquier funcionalidad de sesión, se debe llamar a `session_start()`. Esto crea una nueva sesión o reanuda una sesión existente basada en la cookie de sesión del usuario.

```php
<?php
// Iniciar sesión
session_start();

// Almacenar un valor en la sesión
$_SESSION['usuario'] = 'Carlos';

// Mostrar un valor de la sesión
echo 'Usuario: ' . $_SESSION['usuario'];  // Output: Usuario: Carlos
?>
```
- **`session_start()`**: Debe ser la primera línea del script o justo después de cualquier declaración PHP (antes de la salida de HTML).
- **`$_SESSION['usuario']`**: Guarda el nombre del usuario en la sesión.

### 2. **Almacenar datos en la sesión**
Los datos se pueden almacenar en `$_SESSION` como si fuera un array asociativo.

#### Ejemplo:
```php
<?php
session_start();

// Almacenar múltiples valores
$_SESSION['usuario'] = 'Carlos';
$_SESSION['email'] = 'carlos@example.com';

// Mostrar los valores almacenados
echo 'Usuario: ' . $_SESSION['usuario'] . '<br>';  // Output: Usuario: Carlos
echo 'Email: ' . $_SESSION['email'];  // Output: Email: carlos@example.com
?>
```

### 3. **Leer datos de la sesión**
Una vez que los datos están almacenados en la sesión, puedes acceder a ellos desde cualquier página que utilice `session_start()`.

#### Ejemplo:
```php
<?php
session_start();

// Leer los datos de la sesión
if (isset($_SESSION['usuario'])) {
    echo 'Usuario: ' . $_SESSION['usuario'];  // Output: Usuario: Carlos
} else {
    echo 'No hay usuario en la sesión.';
}
?>
```

### 4. **Eliminar datos de la sesión**
Se pueden eliminar variables de sesión individuales usando `unset()` o destruir toda la sesión con `session_destroy()`.

#### Eliminar una variable específica:
```php
<?php
session_start();

// Eliminar una variable específica de la sesión
unset($_SESSION['usuario']);
```

#### Destruir toda la sesión:
```php
<?php
session_start();

// Eliminar todos los datos de la sesión y destruirla
session_unset();  // Limpia todas las variables de sesión
session_destroy();  // Destruye la sesión actual
?>
```
- **`session_unset()`**: Elimina todas las variables de sesión.
- **`session_destroy()`**: Destruye toda la sesión en el servidor.


## Control de errores.

PHP utiliza dos enfoques principales para el control de errores:

1. **Errores (errors)**: Problemas que ocurren en tiempo de ejecución (como errores de sintaxis o problemas de memoria).
2. **Excepciones (exceptions)**: Mecanismo basado en objetos que permite capturar y manejar errores de manera más estructurada.

PHP 8 introduce mejoras en la gestión de errores, como el tipo de excepciones más estricto y la depuración mejorada.

### Tipos de errores en PHP 8

PHP clasifica los errores en varias categorías:

1. **Errores fatales**: Causan la terminación inmediata del script.
2. **Errores de advertencia (warnings)**: Son problemas no fatales; el script sigue ejecutándose.
3. **Errores de notificación (notices)**: Son advertencias sobre problemas no graves, como el uso de una variable no definida.
4. **Errores de sintaxis (parse errors)**: Ocurren cuando el script no se puede interpretar debido a errores de código.
5. **Excepciones**: Una estructura basada en objetos para manejar errores de forma más controlada.

### 1. **Manejo de errores tradicionales**
El método clásico de control de errores en PHP incluye el uso de funciones como `error_reporting()`, `set_error_handler()`, y `trigger_error()`. Esto permite establecer un controlador de errores personalizado para manejar diversos niveles de errores.

```php
<?php
// Establecer el nivel de reporte de errores
error_reporting(E_ALL);

// Establecer un manejador de errores personalizado
function manejadorDeErrores($errno, $errstr, $errfile, $errline) {
    echo "Error [$errno]: $errstr en $errfile, línea $errline\n";
    return true;  // Previene que PHP maneje el error de forma predeterminada
}

set_error_handler("manejadorDeErrores");

// Provocar un error
echo $variable_no_definida;  // Esto genera un "notice"
?>
```

### 2. **Excepciones en PHP 8**
 PHP tiene un sistema de excepciones que permite capturar errores en bloques de código y manejar estos errores de manera controlada mediante los bloques **`try-catch`**.

#### Bloques `try-catch`:
- **`try`**: Contiene el código que puede generar una excepción.
- **`catch`**: Captura la excepción y ejecuta el código para manejar el error.

```php
<?php
function dividir($dividendo, $divisor) {
    if ($divisor == 0) {
        throw new Exception("División por cero.");
    }
    return $dividendo / $divisor;
}

try {
    echo dividir(10, 2);  // Output: 5
    echo dividir(10, 0);  // Provoca una excepción
} catch (Exception $e) {
    echo "Excepción capturada: " . $e->getMessage();
}
?>
```



### 3. **Error Handling Functions**

- **`set_error_handler()`**: Define una función personalizada para manejar errores.
- **`trigger_error()`**: Lanza un error de usuario (útil para depuración).
- **`error_reporting()`**: Configura el nivel de notificación de errores que será reportado.

```php
<?php
// Usar trigger_error para lanzar un error
if (!file_exists("archivo.txt")) {
    trigger_error("El archivo no existe.", E_USER_WARNING);
}
?>
```

### 4. **Manejo de errores personalizados**
PHP permite definir controladores de errores personalizados utilizando `set_error_handler()` y controladores de excepciones personalizados con `set_exception_handler()`.

```php
<?php
// Establecer un manejador de excepciones personalizado
function manejadorDeExcepciones($exception) {
    echo "Excepción no capturada: " . $exception->getMessage();
}

set_exception_handler('manejadorDeExcepciones');

// Provocar una excepción sin capturar
throw new Exception('Excepción sin capturar.');
?>
```

### 5. **Manejo de errores fatales con `register_shutdown_function()`**
Los errores fatales (que terminan el script) pueden ser manejados con la función `register_shutdown_function()`, que permite ejecutar código al final del script, incluso si ocurrió un error fatal.

```php
<?php
register_shutdown_function(function() {
    $error = error_get_last();
    if ($error) {
        echo "Error fatal: " . $error['message'];
    }
});

// Provocar un error fatal
echo dividir(10, 0);  // Función no definida o error fatal
?>
```

## Conexiones a BD.
OCI8 permite acceder a Oracle Database 12c, 11g, 10g, 9i y 8i. Admiten sentencias SQL y PL/SQL. Sus características básicas incluyen el control de transacciones, la vinculación de variables de PHP a parámetros de sustitución de Oracle, y la admisión de tipos de objetos grandes (LOB) y colecciones.

### Conexión y consulta básica

```php
<?php

// conectamos a la bd con el usuario hr y la contraseña welcome, y connection_string 'localhost/XE'
$conexión = oci_connect('hr', 'welcome', 'localhost/XE');

if (!$conexión) {
    $e = oci_error();
    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);
}

// Preparar la sentencia
$stid = oci_parse($conexión, 'SELECT * FROM departments');
if (!$stid) {
    $e = oci_error($conexión);
    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);
}

// Realizar la lógica de la consulta
$r = oci_execute($stid);
if (!$r) {
    $e = oci_error($stid);
    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);
}

// Obtener los resultados de la consulta
print "<table border='1'>\n";
while ($fila = oci_fetch_array($stid, OCI_ASSOC+OCI_RETURN_NULLS)) {
    print "<tr>\n";
    foreach ($fila as $elemento) {
        print "    <td>" . ($elemento !== null ? htmlentities($elemento, ENT_QUOTES) : "") . "</td>\n";
    }
    print "</tr>\n";
}
print "</table>\n";

oci_free_statement($stid);
oci_close($conexión);
?>
```
